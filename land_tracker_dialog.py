# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LandtrackerDialog
                                 A QGIS plugin
 Plugin to create and analyze route paths
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by asdf
        email                : asdf
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsProject,
    QgsRasterLayer,
    QgsRectangle,
    QgsRasterFileWriter,
    Qgis
)
from qgis.analysis import (
    QgsRasterCalculator,
    QgsRasterCalculatorEntry,
    QgsAlignRaster
)
from qgis import processing

import numpy as np
from osgeo import gdal

import math

from matplotlib import pyplot as plt

import tempfile
#------ CLEAR THIS

from qgis.PyQt.QtWidgets import QGraphicsLineItem, QGraphicsEllipseItem
from qgis.PyQt.QtWidgets import QGraphicsScene, QGraphicsView, QMessageBox, QTableWidgetItem, QDoubleSpinBox

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtCore import QVariant, pyqtSignal, QRectF
from PyQt5.QtGui import QMouseEvent, QColor, QPen, QBrush
from qgis.gui import QgsMapTool, QgsVertexMarker
from qgis.utils import iface
from qgis.core import QgsProject, QgsVectorLayer, QgsGeometry, QgsFeature, QgsPoint, QgsPointXY, QgsCircle, QgsField, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils, QgsDistanceArea, QgsSymbol, QgsRendererRange, QgsGraduatedSymbolRenderer, edit, QgsMapLayerProxyModel, QgsRasterDataProvider, QgsRasterBandStats, QgsProcessing
import processing
from math import *

import time


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'land_tracker_dialog_base.ui'))


class LandtrackerDialog(QtWidgets.QDialog, FORM_CLASS):

    pointSelectTool = None
    basePointX = 0
    basePointY = 0
    pointSelected = False

    directions = {
        0: (-1, 0),   # Top
        1: (-1, 1),   # Top-right
        2: (0, 1),    # Right
        3: (1, 1),    # Bottom-right
        4: (1, 0),    # Bottom
        5: (1, -1),   # Bottom-left
        6: (0, -1),   # Left
        7: (-1, -1)   # Top-left
    }

    def __init__(self, parent=None):
        """Constructor."""
        super(LandtrackerDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.button_box.rejected.connect(self.toolReject)
        self.pointSelectTool = MapTool(iface.mapCanvas())
        self.pointSelectTool.clicked.connect(self.setPoint)
        self.mMapLayerComboBox_DEM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.mMapLayerComboBox_surface.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.mMapLayerComboBox_roads.setFilters(QgsMapLayerProxyModel.LineLayer)
        self.checkBox_enableSurfaceLayer.stateChanged.connect(self.surfaceLayerCheckbox)
        self.checkBox_enableRoadsLayer.stateChanged.connect(self.roadsLayerCheckbox)
        self.pushButton_point.clicked.connect(self.pointButtonClicked)
        self.checkBox_enableSurfaceLayer.stateChanged.connect(self.surfaceLayerCheckBox)
        self.mMapLayerComboBox_surface.layerChanged.connect(self.surfaceLayerChanged)
        self.tableWidget_surfaceParameters.setColumnCount(1)
        self.tableWidget_surfaceParameters.setHorizontalHeaderLabels(["Коэффициент"])
        self.tableWidget_surfaceParameters.resizeColumnsToContents()
        self.pushButton_makeCostMatrix.clicked.connect(self.makeCostMatrix)
        self.pushButton_makePath.clicked.connect(self.makePath)

    def makePath(self):
        rasterMode = self.radioButton_pathOutput_raster.isChecked()
        vectorMode = self.radioButton_pathOutput_vector.isChecked()

        costMatrix = self.mMapLayerComboBox_costMatrixLayer.currentLayer()
        directionMatrix = self.mMapLayerComboBox_directionMatrixLayer.currentLayer()

        if not rasterMode and not vectorMode:
            print("No mode selected!")

        if self.pointSelected:
            directionMatrixData = gdal.Open(str(directionMatrix.source()))
            transform = directionMatrixData.GetGeoTransform()

            origin_x = transform[0]
            origin_y = transform[3]
            pixel_width = transform[1]
            pixel_height = transform[5]

            # Get raster's extent and width/height in pixels
            extent = directionMatrix.extent()
            width = directionMatrix.width()
            height = directionMatrix.height()

            # Calculate pixel size
            pixel_width = extent.width() / width
            pixel_height = extent.height() / height

            pixel_x = int((self.basePointX - origin_x) / pixel_width)
            pixel_y = int((self.basePointY - origin_y) / pixel_height)

            pixel_x = abs(pixel_x)
            pixel_y = abs(pixel_y)
        else:
            print("No point selected!")
            return

        directionMatrixArray = directionMatrixData.ReadAsArray().astype(np.intc)
        costMatrixArray = gdal.Open(str(costMatrix.source())).ReadAsArray().astype(np.intc)
        result = np.full(directionMatrixArray.shape, 0, dtype=np.intc)

        ix, iy = pixel_x, pixel_y
        while directionMatrixArray[iy][ix] != 0:
            last_x = ix
            last_y = iy
            result[iy][ix] = costMatrixArray[iy][ix]
            ix += self.directions[directionMatrixArray[last_y][last_x]-1][1]
            iy += self.directions[directionMatrixArray[last_y][last_x]-1][0]

        if rasterMode:
            print("rasterMode")
            self.writeFile('cheapestPath.tiff', result, directionMatrix.extent(), Qgis.Int32, 0)

            root = QgsProject.instance().layerTreeRoot()
            path = QgsRasterLayer("cheapestPath.tiff", "path")
            QgsProject.instance().addMapLayer(path, False)
            root.insertLayer(0, path)

        elif vectorMode:
            print("vectorMode")

    def makeCostMatrix(self):
        print('make cost matrix')
        pointSelected = False
        demLayer = self.mMapLayerComboBox_DEM.currentLayer()
        roadsEnabled = self.checkBox_enableRoadsLayer.isChecked()
        surfaceEnabled = self.checkBox_enableSurfaceLayer.isChecked()
        if roadsEnabled:
            print("Making roads")
            roadsLayer = self.mMapLayerComboBox_roads.currentLayer()
            extent = demLayer.extent()
            roadsRasterized = processing.run("gdal:rasterize", {
                    'INPUT': roadsLayer,
                    'BURN': 1,
                    'UNITS': 0,
                    'WIDTH': extent.width() / 0.0001,
                    'HEIGHT': extent.height() / 0.0001,
                    'EXTENT': extent,
                    'NODATA': 0.,
                    'DATA_TYPE': 0,
                    'OUTPUT': f'temp/roadsRasterized_temp.tiff'
            })['OUTPUT']
            roadsRasterized = QgsRasterLayer(roadsRasterized)
            print("done.")

        print("aligning rasters")

        # aligning surface raster to dem
        if self.checkBox_alignRasters.isChecked():
            rasterAlign = QgsAlignRaster()
            rasterAlign.setDestinationCrs(QgsCoordinateReferenceSystem.toWkt(QgsCoordinateReferenceSystem.fromEpsgId(4326)))

            if surfaceEnabled:
                surfaceLayer = self.mMapLayerComboBox_surface.currentLayer()
                pixelSizeX = demLayer.rasterUnitsPerPixelX()
                pixelSizeY = demLayer.rasterUnitsPerPixelY()
                rasterAlign.setCellSize(pixelSizeX, pixelSizeY)
                demLayerAlign = QgsAlignRaster.Item(str(demLayer.source()), f"temp/dem_temp.tiff")
                surfaceLayerAlign = QgsAlignRaster.Item(str(surfaceLayer.source()), f"temp/surface_temp.tiff")
                rasterList = [demLayerAlign, surfaceLayerAlign]
                rasterAlign.setRasters(rasterList)
                success = rasterAlign.run()
                print(success)
                if not success:
                    print("Raster alignment error")
                    print(rasterAlign.errorMessage())
                    return
                demLayer = QgsRasterLayer('temp/dem_temp.tiff')
                surfaceLayer = QgsRasterLayer('temp/surface_temp.tiff')

            if roadsEnabled:
                pixelSizesX = []
                pixelSizesY = []
                pixelSizesX.append(demLayer.rasterUnitsPerPixelX())
                pixelSizesY.append(demLayer.rasterUnitsPerPixelY())
                pixelSizesX.append(roadsRasterized.rasterUnitsPerPixelX())
                pixelSizesY.append(roadsRasterized.rasterUnitsPerPixelY())
                if self.comboBox_calculationMode.currentIndex() == 0:
                    pixelSizeX = max(pixelSizesX)
                    pixelSizeY = max(pixelSizesY)
                else:
                    pixelSizeX = min(pixelSizesX)
                    pixelSizeY = min(pixelSizesY)
                rasterAlign.setCellSize(pixelSizeX, pixelSizeY)
                rasterList = []
                rasterList.append(QgsAlignRaster.Item(str(demLayer.source()), f"temp/dem_temp.tiff"))
                rasterList.append(QgsAlignRaster.Item(str(roadsRasterized.source()), f"temp/roads_temp.tiff"))
                if surfaceEnabled:
                    rasterList.append(QgsAlignRaster.Item(str(surfaceLayer.source()), f"temp/surface_temp.tiff"))
                rasterAlign.setRasters(rasterList)
                success = rasterAlign.run()
                print(success)
                if not success:
                    print("Raster alignment error")
                    print(rasterAlign.errorMessage())
                    return

        print("done")

        # ------------------

        self.pointSelectTool.clearMarker()
        iface.mapCanvas().unsetMapTool(self.pointSelectTool)

        basePointX = self.basePointX
        basePointY = self.basePointY

        np.set_printoptions(precision=2)

        if self.checkBox_alignRasters.isChecked():
            demLayer = QgsRasterLayer('temp/dem_temp.tiff')
            if surfaceEnabled:
                surfaceLayer = QgsRasterLayer('temp/surface_temp.tiff')
            if roadsEnabled:
                roadsLayer = QgsRasterLayer('temp/roads_temp.tiff')
        else:
            demLayer = self.mMapLayerComboBox_DEM.currentLayer()
            if surfaceEnabled:
                surfaceLayer = self.mMapLayerComboBox_surface.currentLayer()
            if roadsEnabled:
                roadsLayer = self.mMapLayerComboBox_roads.currentLayer()

        demLayerData = gdal.Open(str(demLayer.source()))
        if surfaceEnabled:
            surfaceLayerData = gdal.Open(str(surfaceLayer.source()))
        if roadsEnabled:
            roadsLayerData = gdal.Open(str(roadsLayer.source()))

        passCoefficients = np.array([])
        if surfaceEnabled:
            table = self.tableWidget_surfaceParameters
            row_count = table.rowCount()
            for row in range(row_count):
                cell_widget = table.cellWidget(row, 0)
                passCoefficients = np.append(passCoefficients, cell_widget.value())
        else:
            passCoefficients = np.append(passCoefficients, 1.)

        print(f"PASS COEFFICIENTS: {passCoefficients}")

        if self.pointSelected:
            transform = demLayerData.GetGeoTransform()

            origin_x = transform[0]
            origin_y = transform[3]
            pixel_width = transform[1]
            pixel_height = transform[5]

            # Get raster's extent and width/height in pixels
            extent = demLayer.extent()
            width = demLayer.width()
            height = demLayer.height()

            # Calculate pixel size
            pixel_width = extent.width() / width
            pixel_height = extent.height() / height

            pixel_x = int((basePointX - origin_x) / pixel_width)
            pixel_y = int((basePointY - origin_y) / pixel_height)

            pixel_x = abs(pixel_x)
            pixel_y = abs(pixel_y)
        else:
            pixel_x = int(demLayer.width() / 2)
            pixel_y = int(demLayer.height() / 2)

        demArray = np.pad(demLayerData.ReadAsArray().astype(np.half), pad_width=1, mode='constant', constant_values=np.inf)
        if np.min(demArray) < 0:
            demArray += abs(np.min(demArray))
        if surfaceEnabled:
            surfaceArray = np.pad(surfaceLayerData.ReadAsArray().astype(np.byte), pad_width=1, mode='constant', constant_values=0)
            if np.min(surfaceArray) > 0:
                surfaceArray = surfaceArray - np.min(surfaceArray)
        if roadsEnabled:
            roadsArray = np.pad(roadsLayerData.ReadAsArray().astype(np.half), pad_width=1, mode='constant', constant_values=np.nan)

        cost_matrices = np.zeros((8, *demArray.shape), dtype=np.half)

        print("calculating cost matrices")
        for i in range(8):
            reverse_direction = (i + 4) % 8

            a = self.array_shift(demArray, self.directions[reverse_direction], 1, np.inf)

            cost_matrices[i] =  a - demArray

            # Replace NaN with inf
            cost_matrices[i][np.isnan(cost_matrices[i])] = np.inf

            # Replace -inf with inf
            cost_matrices[i][np.isneginf(cost_matrices[i])] = np.inf

            if surfaceEnabled:
                cost_matrices[i] = (10 * math.e ** (2*cost_matrices[i]/10)) / passCoefficients[surfaceArray]
            else:
                cost_matrices[i] = (10 * math.e ** (2*cost_matrices[i]/10))

            if roadsEnabled:
                cost_matrices[i][roadsArray == 1.] = 0

        print("done.")
        print(f"cost_matrices price: {cost_matrices.nbytes}")

        mainShape = demArray.shape

        print(pixel_x)
        print(pixel_y)

        hasDelta = True
        resultingCosts = np.full(mainShape, np.inf, dtype=np.half)
        resultingCosts[pixel_y][pixel_x] = 0.
        shortestDirections = np.full(mainShape, 0, dtype=np.byte)

        print(f"resultingCosts price: {resultingCosts.nbytes}")
        print(f"shortestDirections price: {shortestDirections.nbytes}")

        print('performing vortex algorithm...')

        count = 0
        while hasDelta:
            count += 1
            print(f"Iter {count}")
            hasDelta = False
            for i in range(8):
                # 2
                tempCosts = cost_matrices[i] + resultingCosts

                # 4
                tempCosts = self.array_shift(tempCosts, self.directions[i], 1, np.inf)

                mask = tempCosts < resultingCosts
                # 3
                if np.any(mask):
                    hasDelta = True

                    # 1
                    resultingCosts[mask] = tempCosts[mask]
                    shortestDirections[mask] = ((i + 4) % 8) + 1
                else:
                    # print('NO')
                    continue

        print("done.")

        rows = np.sum(np.isfinite(resultingCosts), axis=1) > 2
        cols = np.sum(np.isfinite(resultingCosts), axis=0) > 2

        resultingCosts = resultingCosts[rows,:][:,cols]
        shortestDirections = shortestDirections[rows,:][:,cols]

        print(np.isfinite(resultingCosts).all())

        self.writeFile('cost_matrix.tiff', resultingCosts, self.mMapLayerComboBox_DEM.currentLayer().extent(), Qgis.Int32)
        self.writeFile('direction_matrix.tiff', shortestDirections, self.mMapLayerComboBox_DEM.currentLayer().extent(), Qgis.Byte, 0)

        group = QgsProject.instance().layerTreeRoot().addGroup('Cost Data')

        cost_matrix = QgsRasterLayer("cost_matrix.tiff", "cost_matrix")
        cheapest_directions = QgsRasterLayer("direction_matrix.tiff", "direction_matrix")

        QgsProject.instance().addMapLayer(cost_matrix, False)
        QgsProject.instance().addMapLayer(cheapest_directions, False)

        group.addLayer(cost_matrix)
        group.addLayer(cheapest_directions)

    def writeFile(self, name, array, extent, datatype, noDataValue=-1):
        nx = array.shape[1]
        ny = array.shape[0]

        writer = QgsRasterFileWriter(name)
        provider = QgsRasterFileWriter.createOneBandRaster(
            writer,
            dataType=datatype,
            width=nx,
            height=ny,
            extent=extent,
            crs = QgsCoordinateReferenceSystem(f"epsg:{4326}"),
            )
        provider.setNoDataValue(1, noDataValue)
        provider.setEditable(True)

        block = provider.block(
            bandNo=1,
            boundingBox=provider.extent(),
            width=provider.xSize(),
            height=provider.ySize()
            )

        for ix in range(nx):
            for iy in range(ny):
                value = array[iy][ix]
                if ~np.isfinite(value):
                    block.setValue(iy, ix, -1)
                else:
                    block.setValue(iy, ix, value)

        provider.writeBlock(
            block=block,
            band=1,
            xOffset=0,
            yOffset=0
            )
        provider.setEditable(False)

    def updateTable(self, min, max):
        count = max-min+1
        table = self.tableWidget_surfaceParameters
        table.clearContents()
        table.setRowCount(count)
        labels = []
        for i in range(count):
            labels.append(str(min+i))
            spinBox = QDoubleSpinBox()
            spinBox.setValue(1.)
            spinBox.setSingleStep(.1)
            table.setCellWidget(i, 0, spinBox)
        table.setVerticalHeaderLabels(labels)
        table.resizeColumnsToContents()

    def surfaceLayerChanged(self):
        layer = self.mMapLayerComboBox_surface.currentLayer()
        if layer is not None:
            provider = layer.dataProvider()
            bandCount = provider.bandCount()
            if bandCount == 1:
                dataType = provider.dataType(1)

                # int data types
                if dataType in (1, 2, 3, 4, 5, 8, 9):
                    layer = gdal.Open(str(layer.source()))
                    array = layer.ReadAsArray()
                    min = int(np.min(array))
                    max = int(np.max(array))
                    if min < 0:
                        min = 0
                    print(min)
                    print(max)
                    self.updateTable(min, max)

    def surfaceLayerCheckBox(self):
        state = self.checkBox_enableSurfaceLayer.isChecked()
        self.label_surfaceParameters.setEnabled(state)
        self.tableWidget_surfaceParameters.setEnabled(state)
        if state == True:
            self.surfaceLayerChanged()

    def pointButtonClicked(self):
        state = self.pushButton_point.isChecked()
        if state == True:
            iface.mapCanvas().setMapTool(self.pointSelectTool)
            self.showMinimized()
        else:
            iface.mapCanvas().unsetMapTool(self.pointSelectTool)

    def array_shift(self, array, direction, n=1, fill=np.inf):
        if n < 1:
            return array

        vertical = direction[0]
        horizontal = direction[1]

        rows = array.shape[0]-n
        cols = array.shape[1]-n

        result = np.copy(array)

        # top
        if vertical < 0:
            result[:-n,:] = result[n:,:]
            result[rows:,:] = fill
        # bottom
        if vertical > 0:
            result[n:,:] = result[:rows,:]
            result[:n,:] = fill
        # left
        if horizontal < 0:
            result[:,:cols] = result[:,n:]
            result[:,cols:] = fill
        # right
        if horizontal > 0:
            result[:,n:] = result[:,:cols]
            result[:,:n] = fill

        return result

    def toolReject(self):
        self.pointSelectTool.clearMarker()
        iface.mapCanvas().unsetMapTool(self.pointSelectTool)
        self.reject()

    def closeEvent(self, event):
        # Emit the toolRejected signal
        self.toolReject()
        # Optionally, call any other cleanup code here
        event.accept()  # Accept the event to close the dialog

    def setPoint(self, point):
        self.basePointX = point.x()
        self.basePointY = point.y()
        self.lineEdit_point_x.setText(str(self.basePointX))
        self.lineEdit_point_y.setText(str(self.basePointY))
        self.pointSelected = True
        iface.mapCanvas().unsetMapTool(self.pointSelectTool)
        self.showNormal()
        if self.pushButton_point.isChecked() == True:
            self.pushButton_point.setChecked(False)

    def showEvent(self, e):
        print('showEvent')

    def surfaceLayerCheckbox(self):
        checkBoxState = self.checkBox_enableSurfaceLayer.isChecked()
        self.mMapLayerComboBox_surface.setEnabled(checkBoxState)

    def roadsLayerCheckbox(self):
        checkBoxState = self.checkBox_enableRoadsLayer.isChecked()
        self.mMapLayerComboBox_roads.setEnabled(checkBoxState)

class MapTool(QgsMapTool):

    clicked = pyqtSignal('QgsPointXY')
    canvas = None
    marker = None

    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self.marker = QgsVertexMarker(self.canvas)

    def clearMarker(self):
        self.canvas.scene().removeItem(self.marker)

    def canvasPressEvent(self, e):
        super().canvasPressEvent(e)

        sourceCRS = QgsProject.instance().crs()
        destinationCRS = QgsCoordinateReferenceSystem.fromEpsgId(4326)
        transform = QgsCoordinateTransform()
        transform.setSourceCrs(sourceCRS)
        transform.setDestinationCrs(destinationCRS)
        mapPoint = e.mapPoint()
        mapPoint = transform.transform(mapPoint)

        markerPoint = QgsPointXY(mapPoint.x(), mapPoint.y())
        markerPointTransform = QgsCoordinateTransform(destinationCRS, sourceCRS, QgsProject.instance())
        markerPoint = markerPointTransform.transform(markerPoint)

        self.marker.setCenter(markerPoint)

        self.canvas.scene().addItem(self.marker)
        self.canvas.refresh()

        self.clicked.emit(mapPoint)
